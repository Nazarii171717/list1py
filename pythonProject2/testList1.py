import random
import unittest
from typing import List, Tuple
from findGenes import find_sequence
from list1 import weekday, segment_length, random_walk, dec2bin, dna_complement

"""All tests' classes were generated by AI"""

if __name__ == '__main__':
    unittest.main()


class TestWeekdayFunction(unittest.TestCase):

    def test_weekday(self):
        """Test for correct weekday determination"""
        self.assertEqual(weekday(18, 5, 1992), "Monday")
        self.assertEqual(weekday(27, 8, 2011), "Saturday")
        self.assertEqual(weekday(31, 5, 2021), "Monday")
        self.assertEqual(weekday(1, 12, 1946), "Sunday")
        self.assertEqual(weekday(7, 2, 1960), "Sunday")

    def test_weekday_rare(self):
        """Test for unusual weekday determination"""
        self.assertEqual(weekday(29, 2, 2024), "Thursday")

    def test_weekday_invalid(self):
        """Test for invalid dates to check proper error handling"""
        with self.assertRaises(ValueError):
            weekday(-4, 5, 2000)  # Invalid day
        with self.assertRaises(ValueError):
            weekday(35, 5, 2021)  # Invalid day
        with self.assertRaises(ValueError):
            weekday(30, 13, 2000)  # Invalid month
        with self.assertRaises(ValueError):
            weekday(3, -5, 2000)  # Invalid month
        with self.assertRaises(ValueError):
            weekday(4, 5, -3)  # Invalid year
        with self.assertRaises(ValueError):
            weekday(0, 5, 2000)  # Invalid year
        with self.assertRaises(ValueError):
            weekday(4, 0, 2000)  # Invalid year
        with self.assertRaises(ValueError):
            weekday(29,2,2025) # Invalid day


class TestSegmentLengthFunction(unittest.TestCase):

    # Test if function correctly calculates the intersection when it exists
    def test_segment_length_intersect(self):
        self.assertEqual(segment_length(1, 5, 3, 7), "(3, 5)")
        self.assertEqual(segment_length(-1, 3, 0, 2), "(0, 2)")

    # Test if function correctly returns None when no intersection exists
    def test_segment_length_no_intersect(self):
        self.assertEqual(segment_length(1, 2, 3, 4), None)
        self.assertEqual(segment_length(-3, -1, 0, 3), None)

    # Test if function correctly raises ValueError when input values are invalid
    def test_segment_length_invalid_values(self):
        with self.assertRaises(ValueError):
            self.assertEqual(segment_length(2, 1, 3, 4))
        with self.assertRaises(ValueError):
            self.assertEqual(segment_length(1, 2, 4, 3))

    # Test if function correctly handles cases where borders are equal
    def test_segment_length_equal_borders(self):
        self.assertEqual(segment_length(1, 3, 1, 3), "(1, 3)")
        self.assertEqual(segment_length(-5, -3, -5, -3), "(-5, -3)")


class TestRandomWalk(unittest.TestCase):

    def setUp(self):
        """
        Set up the testing class by seeding the random number generator.
        """
        random.seed(1)

    def test_random_walk_return_value(self):
        """
        Test to ensure the function random_walk returns a list of tuples.
        """
        self.assertIsInstance(random_walk(10), list)
        self.assertTrue(all(isinstance(coord, tuple) for coord in random_walk(10)))

    def test_random_walk_boundary_reached(self):
        """
        Test to ensure the function random_walk stops when it hits a boundary equal to n.
        """
        walk_output = random_walk(5)
        self.assertTrue(any(x == 5 or y == 5 for x, y in walk_output))

    def test_random_walk_path_length(self):
        """
        Test to ensure the function random_walk returns a list of coordinates that is more than 1 in length.
        """
        walk_output = random_walk(5)
        self.assertTrue(len(walk_output) > 1)

    def test_random_walk_first_coordinate(self):
        """
        Test to ensure the function random_walk starts from the origin (0, 0).
        """
        walk_output = random_walk(5)
        self.assertEqual(walk_output[0], (0, 0))

    def test_random_walk_final_coordinate(self):
        """
        Test to ensure the function random_walk ends when any coordinate (x or y) is equal to n.
        """
        walk_output = random_walk(5)
        final_coordinate = walk_output[-1]
        self.assertTrue(final_coordinate[0] == 5 or final_coordinate[1] == 5)


class TestDec2Bin(unittest.TestCase):

    def test_dec2bin_positive(self):
        # Test when x input is a number that has multiple digits.
        self.assertEqual(dec2bin(10), '1010')
        self.assertEqual(dec2bin(255), '11111111')

    def test_dec2bin_zero(self):
        # Test when x input is 0.
        self.assertEqual(dec2bin(0), '0')

    def test_dec2bin_single_digit(self):
        # Test when x input is a single digit other than zero.
        self.assertEqual(dec2bin(2), '10')
        self.assertEqual(dec2bin(5), '101')

    def test_dec2bin_random_number(self):
        # Test the function with a large random number.
        self.assertEqual(dec2bin(123456789), '111010110111100110100010101')


class TestDNAComplement(unittest.TestCase):

    # Test input where all letters are DNA bases
    def test_valid_input(self):
        self.assertEqual(dna_complement('ATCG'), 'TAGC')
        self.assertEqual(dna_complement('TTTT'), 'AAAA')
        self.assertEqual(dna_complement('CCCC'), 'GGGG')
        self.assertEqual(dna_complement('GGGG'), 'CCCC')
        self.assertEqual(dna_complement('AAAA'), 'TTTT')

    # Test invalid inputs which should result in a ValueError
    def test_invalid_input(self):
        with self.assertRaises(ValueError):
            dna_complement('ATCZ')  # Z is not a valid DNA base
        with self.assertRaises(ValueError):
            dna_complement('1234')  # Numbers are not valid DNA bases
        with self.assertRaises(ValueError):
            dna_complement('ATCGH')  # H is not a valid DNA base

    # Test case insensitivity, lower case letters should not be valid DNA bases
    def test_case_insensitivity(self):
        with self.assertRaises(ValueError):
            dna_complement('atcg')
        with self.assertRaises(ValueError):
            dna_complement('ATcG')


class TestFindSequence(unittest.TestCase):

    def test_valid_dna_sequence_with_genes(self):
        # This tests a sequence that is a valid gene,
        # it starts with the start codon 'ATG', ends with a stop codon
        # and its length is a multiple of 3.
        dna_sequence = 'ATGATGATGTAG'
        result = find_sequence(dna_sequence)
        self.assertEqual(result, ['ATGATGATGTAG', 'ATGATGTAG'])

    def test_valid_dna_sequence_with_multiple_genes(self):
        # This tests a sequence with multiple valid genes with length multiple of 3.
        dna_sequence = 'ATGATGATGTAGATGATGTAG'
        result = find_sequence(dna_sequence)
        self.assertEqual(result, ['ATGATGATGTAG', 'ATGATGTAG', 'ATGATGTAG'])

    def test_valid_dna_sequence_without_genes(self):
        # This tests a sequence that does not contain any valid genes.
        dna_sequence = 'GGGAGTAGG'
        result = find_sequence(dna_sequence)
        self.assertEqual(result, [])

    def test_empty_dna_sequence(self):
        # This tests an empty sequence which should not contain any genes.
        dna_sequence = ''
        result = find_sequence(dna_sequence)
        self.assertEqual(result, [])

    def test_invalid_dna_sequence(self):
        # This tests a sequence that contains an invalid char 'C'.
        # ValueError exception should be expected resulting from 'C' character in the dna_sequence.
        dna_sequence = 'ATGATGATGCTAG'
        with self.assertRaises(ValueError):
            find_sequence(dna_sequence)

    def test_dna_sequence_with_no_stop_codon(self):
        # This tests a sequence with no stop codon thus not a valid gene.
        dna_sequence = 'ATGATGATG'
        result = find_sequence(dna_sequence)
        self.assertEqual(result, [])

    def test_dna_sequence_with_no_start_codon(self):
        # This tests a sequence that does not begin with a start codon.
        # Length of the dna_sequence is a multiple of 3 but it does not start with a start codon.
        dna_sequence = 'TTTATGATGTAG'
        result = find_sequence(dna_sequence)
        self.assertEqual(result, ["ATGATGTAG"])

    def test_dna_sequence_with_interleaving_stop_codon(self):
        # This tests an interleaving sequence where the first chunk is a valid gene but the last is not.
        dna_sequence = 'ATGATGTAGATGTAG'
        result = find_sequence(dna_sequence)
        self.assertEqual(result, ['ATGATGTAG'])
